#include "PostProcessing.h"
#include "Transforms.h"

namespace ren::sh {

[[vk::push_constant]] PostProcessingArgs pc;

shared float luminance_histogram[NUM_LUMINANCE_HISTOGRAM_BINS];

[numthreads(8, 8)]
void main() {
  Texture2D hdr = Get(pc.hdr);

  const ivec2 size = TextureSize(hdr);
  const vec2 center = 0.5f * vec2(size);
  const ivec2 stride = ivec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);

  if (pc.luminance_histogram) {
    for (uint i = gl_LocalInvocationIndex; i < NUM_LUMINANCE_HISTOGRAM_BINS; i += gl_WorkGroupSize.x * gl_WorkGroupSize.y) {
      luminance_histogram[i] = 0.0f;
    }
    barrier();
  }

  const ivec2 start = ivec2(gl_GlobalInvocationID.xy);
  for (int x = start.x; x < size.x; x += stride.x) {
    for (int y = start.y; y < size.y; y += stride.y) {
      vec3 color = hdr.Load(int3(x, y, 0)).rgb;

      if (pc.luminance_histogram) {
        float weight = 1.0f;
      
        vec2 relative_centered_pos = 2.0f * (vec2(x + 0.5f, y + 0.5f) - center) / min(size.x, size.y);
        if (pc.metering_mode == METERING_MODE_SPOT) {
          float radius = 0.5f * pc.metering_pattern_relative_inner_size;
          weight = length(relative_centered_pos) < radius ? 1.0f : 0.0f;
        } else if (pc.metering_mode == METERING_MODE_CENTER_WEIGHTED) {
          weight = 1.0f - smoothstep(
            0.5f * pc.metering_pattern_relative_inner_size,
            0.5f * pc.metering_pattern_relative_outer_size,
            length(relative_centered_pos)
          );
        }

        float luminance = max(color_to_luminance(color) / *pc.exposure, MIN_LUMINANCE);
        float log_luminance = log2(luminance);
        float alpha = saturate((log_luminance - MIN_LOG_LUMINANCE) / (MAX_LOG_LUMINANCE - MIN_LOG_LUMINANCE));
        int lo_bin = int(alpha * (NUM_LUMINANCE_HISTOGRAM_BINS - 1));
        int hi_bin = min(lo_bin + 1, NUM_LUMINANCE_HISTOGRAM_BINS - 1);

        float lo_log_luminance = mix(MIN_LOG_LUMINANCE, MAX_LOG_LUMINANCE, float(lo_bin) / (NUM_LUMINANCE_HISTOGRAM_BINS - 1));
        float lo_weight = weight * (2.0f - log_luminance / lo_log_luminance);
        float hi_weight = weight - lo_weight;

        atomicAdd(luminance_histogram[lo_bin], lo_weight);
        atomicAdd(luminance_histogram[hi_bin], hi_weight);
      }

      if (!IsNull(pc.ltm_llm)) {
        Sampler2D ltm_llm = Get(pc.ltm_llm);
        vec2 uv = vec2(x + 0.5f, y + 0.5f) * pc.ltm_inv_size;
        vec2 ab = ltm_llm.SampleLevel(uv, 0).xy;

        float luminance = pc.middle_gray * color_to_luminance(color);
        luminance = tone_map(luminance, pc.tone_mapper);
        luminance = linear_to_srgb(luminance);
        luminance = ab.x * luminance + ab.y;
        luminance = srgb_to_linear(luminance);
        luminance = inverse_tone_map(luminance, pc.tone_mapper);

        color = luminance / color_to_luminance(color) * color;
      } else {
        color = pc.middle_gray * color;
      }

      color = tone_map(color, pc.tone_mapper);
      if (bool(pc.dithering)) {
        color = dither_srgb(color, 8, pc.noise_lut, uvec2(x, y));
      }
      color = linear_to_srgb(color);

      Get(pc.sdr).Store(ivec2(x, y), vec4(color, 1.0f));
    }
  }

  if (pc.luminance_histogram) {
    barrier();
    for (uint i = gl_LocalInvocationIndex; i < NUM_LUMINANCE_HISTOGRAM_BINS; i += gl_WorkGroupSize.x * gl_WorkGroupSize.y) {
      // Ignore bin 0 and zero-valued bins
      if (i > 0 && luminance_histogram[i] > 0.0f) {
        atomicAdd(pc.luminance_histogram[i], luminance_histogram[i]);
      }
    }
  }
}

}
