#include "LocalToneMappingLightness.h"
#include "Transforms.h"

namespace ren::sh {

static const uint LC_SIZE = 24;
shared float load_cache[LC_SIZE][LC_SIZE];
shared float store_cache[LC_SIZE][8];

[[vk::push_constant]] LocalToneMappingLightnessArgs pc;

void filter(uvec2 lxy, float gray, out vec3 lightness, out vec3 weight) {
  [[unroll]] for (uint k = 0; k < 3; ++k) {
    uint x = lxy.x;
    uint y = lxy.y + k * 8;
    float log_luminance = 0.0f;
    log_luminance += -0.04870331f * load_cache[y][2 * x + 1];
    log_luminance += -0.07262685f * load_cache[y][2 * x + 2];
    log_luminance +=  0.16367737f * load_cache[y][2 * x + 3];
    log_luminance +=  0.45765278f * load_cache[y][2 * x + 4];
    log_luminance +=  0.45765278f * load_cache[y][2 * x + 5];
    log_luminance +=  0.16367737f * load_cache[y][2 * x + 6];
    log_luminance += -0.07262685f * load_cache[y][2 * x + 7];
    log_luminance += -0.04870331f * load_cache[y][2 * x + 8];
    store_cache[y][x] = log_luminance;
  }
  barrier();

  float log_luminance = 0.0f;
  {
    uint x = lxy.x;
    uint y = lxy.y;
    log_luminance += -0.04870331f * store_cache[2 * y + 1][x];
    log_luminance += -0.07262685f * store_cache[2 * y + 2][x];
    log_luminance +=  0.16367737f * store_cache[2 * y + 3][x];
    log_luminance +=  0.45765278f * store_cache[2 * y + 4][x];
    log_luminance +=  0.45765278f * store_cache[2 * y + 5][x];
    log_luminance +=  0.16367737f * store_cache[2 * y + 6][x];
    log_luminance += -0.07262685f * store_cache[2 * y + 7][x];
    log_luminance += -0.04870331f * store_cache[2 * y + 8][x];
  }
  float luminance = pc.middle_gray * exp2(log_luminance);

  vec3 exposures = vec3(pc.shadows, 1.0f, pc.highlights);
  [[unroll]] for (uint k = 0; k < 3; ++k) {
    lightness[k] = exposures[k] * luminance;
    lightness[k] = tone_map(lightness[k], pc.tone_mapper);
    lightness[k] = linear_to_srgb(lightness[k]);
    float delta = pc.sigma * (lightness[k] - gray);
    weight[k] = exp(-0.5f * delta * delta);
  }
  weight /= (weight.r + weight.g + weight.b);
}

[numthreads(LTM_LIGHTNESS_GROUP_SIZE_X * LTM_LIGHTNESS_GROUP_SIZE_Y)]
void main() {
  Texture2D hdr = Get(pc.hdr);
  RWTexture2D ltm_lightness = Get(pc.lightness);
  RWTexture2D ltm_weights = Get(pc.weights);

  uvec2 lxy = swizzle_quads(gl_LocalInvocationIndex, LTM_LIGHTNESS_GROUP_SIZE_X);
  ivec2 base_load_xy = ivec2(2 * gl_WorkGroupID.xy * LTM_LIGHTNESS_TILE_SIZE);
  ivec2 min_load_xy = max(0, base_load_xy - 3);
  ivec2 max_load_xy = min(TextureSize(hdr) - 1, base_load_xy + 2 * LTM_LIGHTNESS_TILE_SIZE + 2);

  [[unroll]] for (uint k = 0; k < 9; ++k) {
    uvec2 gxy = swizzle_zz(k, 3);
    ivec2 offset = gxy * LTM_LIGHTNESS_GROUP_SIZE + lxy + ivec2(-4, -4);
    ivec2 load_xy = base_load_xy + offset;
    load_xy = clamp(load_xy, min_load_xy, max_load_xy);
    vec3 color = hdr.Load(ivec3(load_xy, 0)).rgb;
    float luminance = color_to_luminance(color);
    load_cache[offset.y + 4][offset.x + 4] = log2(luminance);
  }
  barrier();

  float gray = tone_map(pc.middle_gray, pc.tone_mapper);
  gray = linear_to_srgb(gray);
  vec3 lightness;
  vec3 weight;
  filter(lxy, gray, lightness, weight);

  ivec2 store_xy = gl_WorkGroupID.xy * LTM_LIGHTNESS_TILE_SIZE + lxy;
  if (all(store_xy < TextureSize(ltm_lightness))) {
    ltm_lightness.Store(store_xy, vec4(lightness, 0));
    ltm_weights.Store(store_xy, vec4(weight.rg, 0));
  }
}

}
