#include "StreamScan.h"

namespace ren::sh {

#define SCAN_TYPE_EXSCLUSIVE 0
#define SCAN_TYPE_INCLUSIVE 1

[[vk::push_constant]] StreamScanArgs pc;

static const uint BLOCK_SIZE = SCAN_BLOCK_SIZE;
static const uint ELEMS = SCAN_THREAD_ELEMS;
static const uint BLOCK_ELEMS = BLOCK_SIZE * ELEMS;

static const uint SHM_ROW_ELEMS = ELEMS + uint(ELEMS % 2 == 0);

groupshared scan_t shm[BLOCK_SIZE][SHM_ROW_ELEMS];
groupshared scan_t scan_shm[BLOCK_SIZE];
groupshared uint bid;
groupshared scan_t block_exc_sum;

[numthreads(BLOCK_SIZE)]
void main() {
  uint lid = gl_LocalInvocationIndex;

  scan_t* src = (scan_t*)pc.src;
  scan_t* block_sums = (scan_t*)pc.block_sums;
  scan_t* dst = (scan_t*)pc.dst;

  if (lid == 0) {
    bid = atomicAdd(*pc.num_started, 1);
  }
  barrier();

  scan_t r = scan_t(0);
  for (uint i = 0; i < ELEMS; ++i) {
    uint gidx = bid * BLOCK_ELEMS + lid * ELEMS + i;
    scan_t v;
#if SCAN_TYPE == SCAN_TYPE_EXSCLUSIVE
    v = gidx > 0 && gidx < pc.count ? src[gidx - 1] : scan_t(0);
#elif SCAN_TYPE == SCAN_TYPE_INCLUSIVE
    v = gidx < n ? src[gidx] : scan_t(0);
#else
#error Unknown SCAN_TYPE
#endif
    r += v;
    shm[lid][i] = v;
  }
  scan_shm[lid] = r;
  barrier();

  for (uint stride = 1; stride < BLOCK_SIZE; stride *= 2) {
    int dst = int(BLOCK_SIZE - lid - 1);
    int src = int(dst - stride);
    scan_t dst_value, src_value;
    if (src >= 0) {
      dst_value = scan_shm[dst];
      src_value = scan_shm[src];
    }
    barrier();
    if (src >= 0) {
      scan_shm[dst] = src_value + dst_value;
    }
    barrier();
  }

  if (lid == 0) {
    while (atomicAdd(*pc.num_finished, 0) != bid) {}
    global_buffer_barrier(MemoryOrder::Acquire);
    scan_t block_sum = scan_shm[BLOCK_SIZE - 1];
    block_exc_sum = bid > 0 ? atomicAdd(block_sums[bid], 0) : scan_t(0);
    atomicMax(block_sums[bid + 1], block_exc_sum + block_sum);
    atomicAdd(*pc.num_finished, 1);
    global_buffer_barrier(MemoryOrder::Release);
  }
  barrier();

  scan_t s = block_exc_sum + (lid > 0 ? scan_shm[lid - 1] : scan_t(0));
  for (uint i = 0; i < ELEMS; ++i) {
    s += shm[lid][i];

    uint gidx = bid * BLOCK_ELEMS + lid * ELEMS + i;
    if (gidx < pc.count) {
      dst[gidx] = s;
    }
  }
}

}
