#include "LocalToneMapping.h"
#include "Transforms.h"

namespace ren::sh {

[[vk::push_constant]] LocalToneMappingArgs pc;

static const uint TILE_WIDTH = LTM_GROUP_SIZE_X * LTM_UNROLL_X;
static const uint TILE_HEIGHT = LTM_GROUP_SIZE_Y * LTM_UNROLL_Y;
static const uvec2 TILE_SIZE = uvec2(TILE_WIDTH, TILE_HEIGHT);

enum {
  LIGHTNESS,
  WEIGHT,
  CHANNEL_COUNT,
};

shared uint lds[CHANNEL_COUNT][2 * TILE_WIDTH * TILE_HEIGHT];

[numthreads(LTM_GROUP_SIZE_X, LTM_GROUP_SIZE_Y)]
void main() {
  Texture2D hdr = Get(pc.hdr);

  [[unroll]]
  for (uint y = 0; y < LTM_UNROLL_Y; ++y) {
    [[unroll]]
    for (uint x = 0; x < LTM_UNROLL_X; ++x) {
      RWTexture2D ltm_lightness = Get(pc.lightness[0]);
      RWTexture2D ltm_weights = Get(pc.weights[0]);

      ivec2 lxy = uvec2(x, y) * gl_WorkGroupSize.xy + gl_LocalInvocationID.xy;
      ivec2 pos = gl_WorkGroupID.xy * TILE_SIZE + lxy;
      pos = min(pos, TextureSize(hdr) - 1);
      uint offset = lxy.y * TILE_WIDTH + lxy.x;

      vec3 color = hdr.Load(ivec3(pos, 0)).rgb;
      float luminance = pc.middle_gray * color_to_luminance(color);

      float gray = tone_map(pc.middle_gray, pc.tone_mapper);
      gray = linear_to_srgb(gray);

      vec3 exposures = vec3(pc.shadows, 1.0f, pc.highlights);
      vec3 lightness;
      vec3 weight;
      for (uint k = 0; k < 3; ++k) {
        lightness[k] = exposures[k] * luminance;
        lightness[k] = tone_map(lightness[k], pc.tone_mapper);
        lightness[k] = linear_to_srgb(lightness[k]);
        float delta = pc.sigma * (lightness[k] - gray);
        weight[k] = exp(-0.5f * delta * delta);
      }
      lds[LIGHTNESS][offset] = pack_r10g10b10a2_unorm(lightness);
      ltm_lightness.Store(pos, vec4(lightness, 1.0f));
      weight /= (weight.r + weight.g + weight.b);
      lds[WEIGHT][offset] = packUnorm2x16(weight.rg);
      ltm_weights.Store(pos, vec4(weight.rg, 0.0f, 0.0f));
    }
  }

  uint lds_base = 0;
  [[unroll]]
  for (uint mip = 1; mip < LTM_PYRAMID_SIZE + 1; ++mip) {
    if (IsNull(pc.lightness[mip - 1])) {
      return;
    }
    RWTexture2D ltm_lightness = Get(pc.lightness[mip]);
    RWTexture2D ltm_weights = Get(pc.weights[mip]);

    barrier();

    uint size = TILE_WIDTH >> mip;
    bool active = gl_LocalInvocationID.x < size && gl_LocalInvocationID.y < size;

    vec3 lightness = 0.0f;
    vec2 weight = 0.0f;
    if (active) {
      [[unroll]]
      for (uint i = 0; i < 4; ++i) {
        uvec2 lxy = 2 * gl_LocalInvocationID.xy + uvec2(i % 2, i / 2);
        uint offset = lds_base + lxy.y * 2 * size + lxy.x;
        lightness += unpack_r10g10b10a2_unorm(lds[LIGHTNESS][offset]).rgb;
        weight += unpackUnorm2x16(lds[WEIGHT][offset]);
      }
    }
    lightness *= 0.25f;
    weight *= 0.25f;

    lds_base += 4 * size * size;
    uint offset = lds_base + gl_LocalInvocationID.y * size + gl_LocalInvocationID.x;
    ivec2 pos = gl_WorkGroupID.xy * size + gl_LocalInvocationID.xy;

    if (active) {
      lds[LIGHTNESS][offset] = pack_r10g10b10a2_unorm(lightness);
      lds[WEIGHT][offset] = packUnorm2x16(weight);

      if (all(pos < TextureSize(ltm_lightness).xy)) {
        ltm_lightness.Store(pos, vec4(lightness, 1.0f));
        ltm_weights.Store(pos, vec4(weight, 0.0f, 0.0f));
      }
    }
  }
}

}
