#include "Ssao.h"
#include "Random.h"
#include "Transforms.h"

namespace ren::sh {

[[vk::push_constant]] SsaoArgs pc;

float integrate_ao(float noise, vec3 p, vec3 n) {
  // To optimize cache usage, limit the size of the area that a work group samples at a specific mip.
  // Set this area's diameter to twice the work group's size.
  // This means that threads at the work group's sides must have a sampling radius equal to half of a work group's size.
  const float hi_z_r0_pixels = 0.5f * gl_WorkGroupSize.x;
  // Calculate mip 0 view-space radius.
  const vec2 size = TextureSize(Get(pc.hi_z));
  const vec2 hi_z_r0_uv = hi_z_r0_pixels / size;
  const vec2 hi_z_r0_ndc = 2.0f * hi_z_r0_uv;
  const vec2 hi_z_r0_view = hi_z_r0_ndc * -p.z * vec2(pc.rcp_p00, pc.rcp_p11);
  // Select the minimum one so we don't end up outside the predefined area in NDC.
  const float inv_hi_z_r0_view = 1.0f / min(hi_z_r0_view.x, hi_z_r0_view.y);

  vec3 t = normalize(make_orthogonal_vector(n));
  vec3 b = cross(n, t);
  mat3 tbn = mat3(t, b, n);

  vec3 p_ndc = view_to_ndc(pc.p00, pc.p11, pc.znear, p);

  float ka = 0.0f;
  for (float k = 0; k < pc.num_samples; ++k) {
    vec3 Xi = r3_seq(k);
    float phi = TWO_PI * (Xi.x + noise);
    float cos_theta = sqrt(Xi.y);
    float sin_theta = sqrt(1.0f - Xi.y);
    float sample_distance = pc.radius * Xi.z * Xi.z;

    vec3 sample_ts = sample_distance * vec3(sin_theta * cos(phi), sin_theta * sin(phi), cos_theta);
    vec3 sample_view = p + tbn * sample_ts;
    vec3 sample_ndc = view_to_ndc(pc.p00, pc.p11, pc.znear, sample_view);
    vec2 sample_uv = ndc_to_uv(sample_ndc.xy);

    // Find the closest frustum plane intersected by the sampling ray.
    vec3 ray_ndc = sample_ndc - p_ndc;

    // Select frustum planes based on ray's direction.
    vec3 planes = vec3(
      ray_ndc.x > 0.0f ? 1.0f : -1.0f,
      ray_ndc.y > 0.0f ? 1.0f : -1.0f,
      ray_ndc.z > 0.0f ? 1.0f :  0.0f
    );

    // Select closest intersected plane.
    // Negative distances means that the sample is outside the frustum.
    vec3 a = (planes - sample_ndc) / ray_ndc;
    float amin = min(a.x, min(a.y, a.z));
    vec3 intersect_ndc = sample_ndc + amin * ray_ndc;
    vec3 intersect_view = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, intersect_ndc);
    float frustum_distance = length(intersect_view - sample_view);
    // Calculate an attenuation factor for samples that are close to frustum's sides or off screen
    // to avoid sudden changes in occlusion when something enters or exists the screen.
    float offscreen_falloff = amin > 0.0f ? smoothstep(0.0f, 0.5f * pc.radius, frustum_distance) : 0.0f;

    // Add 0.5 because r0 should be the maximum radius at which we sample mip 0.
    float mip = log2(sample_distance * inv_hi_z_r0_view) + 0.5f + pc.lod_bias;

    float z = Get(pc.hi_z).SampleLevel(sample_uv, mip).r;
    z = -(z + pc.znear);
    vec3 occluder_ndc = vec3(sample_ndc.xy, -pc.znear / z);
    vec3 occluder_view = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, occluder_ndc);
    float occluder_distance = length(occluder_view - p);
    // Calculate an attenuation factor for distant occluders to avoid halo artifacts.
    float distance_falloff = 1.0f - smoothstep(pc.radius, 1.5f * pc.radius, occluder_distance);
    
    float w = clamp(1.0f - offscreen_falloff * distance_falloff, 0.0f, 1.0f);

    ka += z > sample_view.z ? w : 1.0f;
  }

  return ka / pc.num_samples;
}

[numthreads(16, 16)]
void main() {
  Sampler2D depth = Get(pc.depth);
  RWTexture2D ssao = Get(pc.ssao);

  const ivec2 depth_size = TextureSize(depth);
  const vec2 inv_depth_size = 1.0f / TextureSize(depth);
  const ivec2 ssao_size = TextureSize(ssao);
  const bool full_res = depth_size == ssao_size;

  // Reconstruct normal from depth buffer:
  // https://atyuwen.github.io/posts/normal-reconstruction
  // This works fine in general, but fails for small or thin triangles.
  // TODO: as a fallback, try to derive the normal by viewing the depth buffer as a height-map and differentiating it.

  vec2 uv = (gl_GlobalInvocationID.xy + 0.5f) / ssao_size;
  float d;
  if (full_res) {
    d = depth.SampleLevel(uv, 0).r;
  } else {
    vec4 gd = depth.Gather(uv);
    d = reduce_quad_checkered_min_max(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y, gd);
    Get(pc.ssao_depth).Store(gl_GlobalInvocationID.xy, pack_depth_linear_16bit(d, pc.znear));
    uvec2 off = uvec2(0, 1);
    off = gd.y == d ? uvec2(1, 1) : off;
    off = gd.z == d ? uvec2(1, 0) : off;
    off = gd.w == d ? uvec2(0, 0) : off;
    uv = (2 * gl_GlobalInvocationID.xy + off + 0.5f) * inv_depth_size;
  }

  vec3 p0 = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, vec3(uv_to_ndc(uv), d));
  bool flipn = false;

  vec3 pt;
  {
    vec4 h;
    h.z = depth.SampleLevel(uv - vec2(2, 0) * inv_depth_size, 0.0f).r;
    h.x = depth.SampleLevel(uv - vec2(1, 0) * inv_depth_size, 0.0f).r;
    h.y = depth.SampleLevel(uv + vec2(1, 0) * inv_depth_size, 0.0f).r;
    h.w = depth.SampleLevel(uv + vec2(2, 0) * inv_depth_size, 0.0f).r;

    vec2 he = abs(2.0f * h.xy - h.zw - d);
    if (he.x < he.y) {
      pt = vec3(uv_to_ndc(uv - vec2(1, 0) * inv_depth_size), h.x);
      flipn = true;
    } else {
      pt = vec3(uv_to_ndc(uv + vec2(1, 0) * inv_depth_size), h.y);
    }
    pt = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, pt);
  }

  vec3 pb;
  {
    vec4 v;
    v.z = depth.SampleLevel(uv - vec2(0, 2) * inv_depth_size, 0.0f).r;
    v.x = depth.SampleLevel(uv - vec2(0, 1) * inv_depth_size, 0.0f).r;
    v.y = depth.SampleLevel(uv + vec2(0, 1) * inv_depth_size, 0.0f).r;
    v.w = depth.SampleLevel(uv + vec2(0, 2) * inv_depth_size, 0.0f).r;
  
    vec2 ve = abs(2.0f * v.xy - v.zw - d);
    if (ve.x < ve.y) {
      pb = vec3(uv_to_ndc(uv - vec2(0, 1) * inv_depth_size), v.x);
    } else {
      pb = vec3(uv_to_ndc(uv + vec2(0, 1) * inv_depth_size), v.y);
      flipn = !flipn;
    }
    pb = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, pb);
  }

  vec3 t = pt - p0;
  vec3 b = pb - p0;
  vec3 n = normalize(cross(t, b));
  n = flipn ? -n : n;

  // Add normal offset to avoid self-shadowing of flat surfaces.
  vec2 pixel_size = pixel_view_space_size(pc.rcp_p00, pc.rcp_p11, inv_depth_size, p0.z);
  p0 = normal_offset(p0, vec3(0.0f, 0.0f, 1.0f), n, pixel_size);

  uvec2 h2d = gl_GlobalInvocationID.xy % SSAO_HILBERT_CURVE_SIZE;
  float noise = pc.noise_lut[h2d.y * SSAO_HILBERT_CURVE_SIZE + h2d.x];
  float ka = integrate_ao(noise, p0, n);

  ssao.Store(gl_GlobalInvocationID.xy, ka);
}

}
