#include "Ssao.h"
#include "Lighting.h"
#include "Random.h"
#include "Texture.glsl"
#include "Transforms.h"
#include "Vertex.h"

LOCAL_SIZE_2D(16, 16);

// TODO:
// 1. Fix off-screen samples and samples close to camera.
// 2. Blur.
// 3. Half-res.
// 4. Optimize sample placement.

vec3 importance_sample_ao_volume(vec3 xi, vec3 n, out float ro) {
  ro = xi.z * xi.z;
  return importance_sample_cosine_weighted_hemisphere(xi.xy, n);
}

float integrate_ao(vec3 p, vec3 n) {
  // To optimize cache usage, limit the size of the area that a work group samples at a specific mip.
  // Set this area's diameter to twice the work group's size.
  // This means that threads at the work group's sides must have a sampling radius equal to half of a work group's size.
  const float hi_z_r0_pixels = 0.5f * gl_WorkGroupSize.x;
  // Calculate mip 0 view-space radius.
  const vec2 size = texture_size(pc.hi_z);
  const vec2 hi_z_r0_uv = hi_z_r0_pixels / size;
  const vec2 hi_z_r0_ndc = 2.0f * hi_z_r0_uv;
  const vec2 hi_z_r0_view = hi_z_r0_ndc * -p.z * vec2(pc.rcp_p00, pc.rcp_p11);
  // Select the minimum one so we don't end up outside the predefined area in NDC.
  const float inv_hi_z_r0_view = 1.0f / min(hi_z_r0_view.x, hi_z_r0_view.y);

  float radius = pc.radius;

  // Add extra rotation around normal to avoid banding artifacts.
  float rot = corput_base_2(gl_GlobalInvocationID.x) + corput_base_3(gl_GlobalInvocationID.y);

  float ka = 0.0f;
  for (uint k = 1; k <= pc.num_samples; ++k) {
    vec3 xi = hammersley_3d(k, pc.num_samples);
    xi.x += rot;
    float ro;
    vec3 l = importance_sample_ao_volume(xi, n, ro);
    vec3 sample_view = p + l * (ro * radius);
    vec2 sample_ndc = view_to_ndc(pc.p00, pc.p11, pc.znear, sample_view).xy;
    vec2 sample_uv = ndc_to_uv(sample_ndc);

    // Add 0.5 because r0 should be the maximum radius at which we sample mip 0.
    float mip = log2(ro * radius * inv_hi_z_r0_view) + 0.5f + pc.lod_bias;

    float z = texture_lod(pc.hi_z, sample_uv, mip).r;
    z = -(z + pc.znear);
    float w = min(abs(z - p.z) / radius, 1.0f);

    ka += z > sample_view.z ? w : 1.0f;
  }

  return ka / pc.num_samples;
}

void main() {
  const uvec2 pos = gl_GlobalInvocationID.xy;

  // Reconstruct normal from depth buffer:
  // https://atyuwen.github.io/posts/normal-reconstruction
  // This works fine in general, but fails for small or thin triangles.
  // TODO: as a fallback, try to derive the normal by viewing the depth buffer as a height-map and differentiating it.

  // TODO: half-resolution.
  vec2 inv_size = 1.0f / texture_size(pc.depth);

  vec2 uv = (pos + 0.5f) * inv_size;

  float d = texture_lod(pc.depth, uv, 0.0f).r;
  vec3 p0 = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, vec3(uv_to_ndc(uv), d));
  bool flipn = false;

  vec3 pt;
  {
    vec4 h;
    h.z = texture_lod(pc.depth, uv - vec2(2, 0) * inv_size, 0.0f).r;
    h.x = texture_lod(pc.depth, uv - vec2(1, 0) * inv_size, 0.0f).r;
    h.y = texture_lod(pc.depth, uv + vec2(1, 0) * inv_size, 0.0f).r;
    h.w = texture_lod(pc.depth, uv + vec2(2, 0) * inv_size, 0.0f).r;

    vec2 he = abs(2.0f * h.xy - h.zw - d);
    if (he.x < he.y) {
      pt = vec3(uv_to_ndc((pos + vec2(-0.5f, 0.5f)) * inv_size), h.x);
      flipn = true;
    } else {
      pt = vec3(uv_to_ndc((pos + vec2( 1.5f, 0.5f)) * inv_size), h.y);
    }
    pt = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, pt);
  }

  vec3 pb;
  {
    vec4 v;
    v.z = texture_lod(pc.depth, uv - vec2(0, 2) * inv_size, 0.0f).r;
    v.x = texture_lod(pc.depth, uv - vec2(0, 1) * inv_size, 0.0f).r;
    v.y = texture_lod(pc.depth, uv + vec2(0, 1) * inv_size, 0.0f).r;
    v.w = texture_lod(pc.depth, uv + vec2(0, 2) * inv_size, 0.0f).r;
  
    vec2 ve = abs(2.0f * v.xy - v.zw - d);
    if (ve.x < ve.y) {
      pb = vec3(uv_to_ndc((pos + vec2(0.5f, -0.5f)) * inv_size), v.x);
    } else {
      pb = vec3(uv_to_ndc((pos + vec2(0.5f,  1.5f)) * inv_size), v.y);
      flipn = !flipn;
    }
    pb = ndc_to_view(pc.rcp_p00, pc.rcp_p11, pc.znear, pb);
  }

  vec3 t = pt - p0;
  vec3 b = pb - p0;
  vec3 n = normalize(cross(t, b));
  n = flipn ? -n : n;

  // Add normal offset to avoid self-shadowing of flat surfaces.
  vec2 pixel_size = pixel_view_space_size(pc.rcp_p00, pc.rcp_p11, 1.0f / texture_size(pc.depth), p0.z);
  p0 = normal_offset(p0, vec3(0.0f, 0.0f, 1.0f), n, pixel_size);

  float ka = integrate_ao(p0, n);

  image_store(pc.ssao, ivec2(pos), ka);
}
